package component

import (
	"strings"

	"gno.land/p/nt/ufmt"
)

type JsonLDMap map[string]interface{}

// StringWithCID returns the JSON-LD string representation with the {{CID}} placeholder replaced by the actual CID.
func (ld JsonLDMap) StringWithCID() string {
	return strings.ReplaceAll(ld.String(), "{{CID}}", ld.Cid())
}

// String returns the JSON-LD string representation.
func (ld JsonLDMap) String() string {
	s := "{\n"
	i := 0
	n := len(ld)
	for k, v := range ld {
		s += `  "` + k + `": ` + toJSONString(v)
		if i < n-1 {
			s += ",\n"
		} else {
			s += "\n"
		}
		i++
	}
	s += "}"
	return s
}

func (ld JsonLDMap) Cid() string {
	return ShaToCid(HashString(ld.String()))
}

func (ld JsonLDMap) StringVal(key string) string {
	if v, ok := ld[key]; ok {
		return v.(string)
	}
	return ""
}

// FIXME: nested types get string encoded - see aiblabes .about

func toJSONString(v interface{}) string {
	switch val := v.(type) {
	case string:
		return `"` + val + `"`
	case float64, float32, int, int64, int32, bool:
		return ufmt.Sprintf("%v", val)
	case JsonLDMap:
		return val.String()
	case map[string]interface{}:
		return JsonLDMap(val).String()
	case []map[string]interface{}:
		s := "["
		for i, elem := range val {
			if i > 0 {
				s += ", "
			}
			s += JsonLDMap(elem).String()
		}
		s += "]"
		return s
	case []interface{}:
		s := "["
		for i, elem := range val {
			if i > 0 {
				s += ", "
			}
			s += toJSONString(elem)
		}
		s += "]"
		return s
	case []string:
		s := "["
		for i, elem := range val {
			if i > 0 {
				s += ", "
			}
			s += `"` + elem + `"`
		}
		s += "]"
		return s
	default:
		return `"` + ufmt.Sprintf("%v", val) + `"`
	}
}

func (ld JsonLDMap) MarkdownLinks() string {
	var collectUrls func(interface{}, string, map[string]string)
	collectUrls = func(v interface{}, path string, urls map[string]string) {
		switch val := v.(type) {
		case map[string]interface{}:
			for k, v2 := range val {
				newPath := strings.Trim(k, "@")
				if path != "" {
					newPath = path + "." + k
				}
				if k == "url" || k == "sameAs" {
					if urlStr, ok := v2.(string); ok {
						urls[newPath] = "[" + urlStr + "](" + urlStr + ")"
					}
					if urlArr, ok := v2.([]string); ok {
						for i, u := range urlArr {
							urls[newPath+ufmt.Sprintf("[%d]", i)] = "[" + u + "](" + u + ")"
						}
					}
				} else if k == "license" {
					if licStr, ok := v2.(string); ok && (strings.HasPrefix(licStr, "http://") || strings.HasPrefix(licStr, "https://")) {
						urls[newPath] = "[" + licStr + "](" + licStr + ")"
					}
				} else if k == "thumbnailUrl" {
					if licStr, ok := v2.(string); ok && (strings.HasPrefix(licStr, "?") || strings.HasPrefix(licStr, "/r/")) {
						urls[newPath] = "[" + licStr + "](" + licStr + ")"
					}
				} else if k == "image" {
					if licStr, ok := v2.(string); ok && (strings.HasPrefix(licStr, "?") || strings.HasPrefix(licStr, "/r/")) {
						urls[newPath] = "[" + licStr + "](" + licStr + ")"
					}
				} else if k == "parentId" || k == "seal" {
					if str, ok := v2.(string); ok && str != "" {
						if IsCIDv1(str) {
							urls[newPath] = "[" + str + "](?cid=" + str + ")"
						}
					}
				} else {
					collectUrls(v2, newPath, urls)
				}
			}
		case JsonLDMap:
			collectUrls(map[string]interface{}(val), path, urls)
		case []interface{}:
			for i, elem := range val {
				idxPath := path + "[" + ufmt.Sprintf("%d", i) + "]"
				collectUrls(elem, idxPath, urls)
			}
		}
	}
	urls := make(map[string]string)
	collectUrls(ld, "", urls)
	table := "| Key | Value |\n| --- | ----- |\n"
	for k, v := range urls {
		table += "| " + k + " | " + v + " |\n"
	}
	return table
}

func (ld JsonLDMap) TermSet() []map[string]any {
	if v, ok := ld["hasDefinedTerm"]; ok {
		defs := v.(map[string]interface{})
		if terms, ok := defs["hasDefinedTerm"]; ok {
			return terms.([]map[string]any)
		}
	}
	return nil
}

func (ld JsonLDMap) MarkdownTerms() string {
	terms := ld.TermSet()
	if terms == nil {
		return "nil"
	}
	if terms == nil || len(terms) == 0 {
		return ""
	}
	table := "| Name | Description |\n| ---- | ----------- |\n"
	for _, term := range terms {
		name := toMarkdownValue(term["name"])
		desc := toMarkdownValue(term["description"])
		table += "| " + name + " | " + desc + " |\n"
	}
	return table
}

// Helper to format value for markdown (no JSON)
func toMarkdownValue(v interface{}) string {
	switch val := v.(type) {
	case string:
		return val
	case float64, float32, int, int64, int32, bool:
		return ufmt.Sprintf("%v", val)
	default:
		return ufmt.Sprintf("%v", val)
	}
}
